// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct Layer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_8() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsLayer(bb: ByteBuffer) -> Layer { return Layer(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case idx = 4
    case type = 6
    case name = 8
    case weights = 10
    case weightsShape = 12
    case bias = 14
    case biasShape = 16
    case probability = 18
    case startDim = 20
    case endDim = 22
    case outSize = 24
    case eps = 26
    case momentum = 28
    case numBatchesTracked = 30
    case runningMean = 32
    case runningMeanShape = 34
    case runningVar = 36
    case runningVarShape = 38
    case kernelSize = 40
    case dilation = 42
    case groups = 44
    case inChannels = 46
    case outChannels = 48
    case padMode = 50
    case padding = 52
    case paddingString = 54
    case stride = 56
    case dataLayout = 58
    case ceilMode = 60
    case upscaleFactor = 62
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var idx: Int32 { let o = _accessor.offset(VTOFFSET.idx.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var hasWeights: Bool { let o = _accessor.offset(VTOFFSET.weights.v); return o == 0 ? false : true }
  public var weightsCount: Int32 { let o = _accessor.offset(VTOFFSET.weights.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func weights(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.weights.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var weights: [Float32] { return _accessor.getVector(at: VTOFFSET.weights.v) ?? [] }
  public var hasWeightsShape: Bool { let o = _accessor.offset(VTOFFSET.weightsShape.v); return o == 0 ? false : true }
  public var weightsShapeCount: Int32 { let o = _accessor.offset(VTOFFSET.weightsShape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func weightsShape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.weightsShape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var weightsShape: [Int32] { return _accessor.getVector(at: VTOFFSET.weightsShape.v) ?? [] }
  public var hasBias: Bool { let o = _accessor.offset(VTOFFSET.bias.v); return o == 0 ? false : true }
  public var biasCount: Int32 { let o = _accessor.offset(VTOFFSET.bias.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func bias(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.bias.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var bias: [Float32] { return _accessor.getVector(at: VTOFFSET.bias.v) ?? [] }
  public var hasBiasShape: Bool { let o = _accessor.offset(VTOFFSET.biasShape.v); return o == 0 ? false : true }
  public var biasShapeCount: Int32 { let o = _accessor.offset(VTOFFSET.biasShape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func biasShape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.biasShape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var biasShape: [Int32] { return _accessor.getVector(at: VTOFFSET.biasShape.v) ?? [] }
  public var probability: Float32 { let o = _accessor.offset(VTOFFSET.probability.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var startDim: Int32 { let o = _accessor.offset(VTOFFSET.startDim.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var endDim: Int32 { let o = _accessor.offset(VTOFFSET.endDim.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var hasOutSize: Bool { let o = _accessor.offset(VTOFFSET.outSize.v); return o == 0 ? false : true }
  public var outSizeCount: Int32 { let o = _accessor.offset(VTOFFSET.outSize.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func outSize(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.outSize.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var outSize: [Int32] { return _accessor.getVector(at: VTOFFSET.outSize.v) ?? [] }
  public var eps: Float32 { let o = _accessor.offset(VTOFFSET.eps.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var momentum: Float32 { let o = _accessor.offset(VTOFFSET.momentum.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var numBatchesTracked: Int32 { let o = _accessor.offset(VTOFFSET.numBatchesTracked.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var hasRunningMean: Bool { let o = _accessor.offset(VTOFFSET.runningMean.v); return o == 0 ? false : true }
  public var runningMeanCount: Int32 { let o = _accessor.offset(VTOFFSET.runningMean.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func runningMean(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.runningMean.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var runningMean: [Float32] { return _accessor.getVector(at: VTOFFSET.runningMean.v) ?? [] }
  public var hasRunningMeanShape: Bool { let o = _accessor.offset(VTOFFSET.runningMeanShape.v); return o == 0 ? false : true }
  public var runningMeanShapeCount: Int32 { let o = _accessor.offset(VTOFFSET.runningMeanShape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func runningMeanShape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.runningMeanShape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var runningMeanShape: [Int32] { return _accessor.getVector(at: VTOFFSET.runningMeanShape.v) ?? [] }
  public var hasRunningVar: Bool { let o = _accessor.offset(VTOFFSET.runningVar.v); return o == 0 ? false : true }
  public var runningVarCount: Int32 { let o = _accessor.offset(VTOFFSET.runningVar.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func runningVar(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.runningVar.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var runningVar: [Float32] { return _accessor.getVector(at: VTOFFSET.runningVar.v) ?? [] }
  public var hasRunningVarShape: Bool { let o = _accessor.offset(VTOFFSET.runningVarShape.v); return o == 0 ? false : true }
  public var runningVarShapeCount: Int32 { let o = _accessor.offset(VTOFFSET.runningVarShape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func runningVarShape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.runningVarShape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var runningVarShape: [Int32] { return _accessor.getVector(at: VTOFFSET.runningVarShape.v) ?? [] }
  public var hasKernelSize: Bool { let o = _accessor.offset(VTOFFSET.kernelSize.v); return o == 0 ? false : true }
  public var kernelSizeCount: Int32 { let o = _accessor.offset(VTOFFSET.kernelSize.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func kernelSize(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.kernelSize.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var kernelSize: [Int32] { return _accessor.getVector(at: VTOFFSET.kernelSize.v) ?? [] }
  public var hasDilation: Bool { let o = _accessor.offset(VTOFFSET.dilation.v); return o == 0 ? false : true }
  public var dilationCount: Int32 { let o = _accessor.offset(VTOFFSET.dilation.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dilation(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.dilation.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var dilation: [Int32] { return _accessor.getVector(at: VTOFFSET.dilation.v) ?? [] }
  public var groups: Int32 { let o = _accessor.offset(VTOFFSET.groups.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var inChannels: Int32 { let o = _accessor.offset(VTOFFSET.inChannels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var outChannels: Int32 { let o = _accessor.offset(VTOFFSET.outChannels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var padMode: String? { let o = _accessor.offset(VTOFFSET.padMode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var padModeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.padMode.v) }
  public var hasPadding: Bool { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? false : true }
  public var paddingCount: Int32 { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func padding(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var padding: [Int32] { return _accessor.getVector(at: VTOFFSET.padding.v) ?? [] }
  public var paddingString: String? { let o = _accessor.offset(VTOFFSET.paddingString.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var paddingStringSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.paddingString.v) }
  public var hasStride: Bool { let o = _accessor.offset(VTOFFSET.stride.v); return o == 0 ? false : true }
  public var strideCount: Int32 { let o = _accessor.offset(VTOFFSET.stride.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func stride(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.stride.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var stride: [Int32] { return _accessor.getVector(at: VTOFFSET.stride.v) ?? [] }
  public var dataLayout: String? { let o = _accessor.offset(VTOFFSET.dataLayout.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dataLayoutSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dataLayout.v) }
  public var ceilMode: Bool { let o = _accessor.offset(VTOFFSET.ceilMode.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  public var upscaleFactor: Int32 { let o = _accessor.offset(VTOFFSET.upscaleFactor.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startLayer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 30) }
  public static func add(idx: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: idx, def: 0, at: VTOFFSET.idx.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func addVectorOf(weights: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: weights, at: VTOFFSET.weights.p) }
  public static func addVectorOf(weightsShape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: weightsShape, at: VTOFFSET.weightsShape.p) }
  public static func addVectorOf(bias: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bias, at: VTOFFSET.bias.p) }
  public static func addVectorOf(biasShape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: biasShape, at: VTOFFSET.biasShape.p) }
  public static func add(probability: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: probability, def: 0.0, at: VTOFFSET.probability.p) }
  public static func add(startDim: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: startDim, def: 0, at: VTOFFSET.startDim.p) }
  public static func add(endDim: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: endDim, def: 0, at: VTOFFSET.endDim.p) }
  public static func addVectorOf(outSize: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: outSize, at: VTOFFSET.outSize.p) }
  public static func add(eps: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: eps, def: 0.0, at: VTOFFSET.eps.p) }
  public static func add(momentum: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: momentum, def: 0.0, at: VTOFFSET.momentum.p) }
  public static func add(numBatchesTracked: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numBatchesTracked, def: 0, at: VTOFFSET.numBatchesTracked.p) }
  public static func addVectorOf(runningMean: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: runningMean, at: VTOFFSET.runningMean.p) }
  public static func addVectorOf(runningMeanShape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: runningMeanShape, at: VTOFFSET.runningMeanShape.p) }
  public static func addVectorOf(runningVar: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: runningVar, at: VTOFFSET.runningVar.p) }
  public static func addVectorOf(runningVarShape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: runningVarShape, at: VTOFFSET.runningVarShape.p) }
  public static func addVectorOf(kernelSize: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: kernelSize, at: VTOFFSET.kernelSize.p) }
  public static func addVectorOf(dilation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dilation, at: VTOFFSET.dilation.p) }
  public static func add(groups: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: groups, def: 0, at: VTOFFSET.groups.p) }
  public static func add(inChannels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inChannels, def: 0, at: VTOFFSET.inChannels.p) }
  public static func add(outChannels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: outChannels, def: 0, at: VTOFFSET.outChannels.p) }
  public static func add(padMode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: padMode, at: VTOFFSET.padMode.p) }
  public static func addVectorOf(padding: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: padding, at: VTOFFSET.padding.p) }
  public static func add(paddingString: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: paddingString, at: VTOFFSET.paddingString.p) }
  public static func addVectorOf(stride: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stride, at: VTOFFSET.stride.p) }
  public static func add(dataLayout: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataLayout, at: VTOFFSET.dataLayout.p) }
  public static func add(ceilMode: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ceilMode, def: false,
   at: VTOFFSET.ceilMode.p) }
  public static func add(upscaleFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: upscaleFactor, def: 0, at: VTOFFSET.upscaleFactor.p) }
  public static func endLayer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLayer(
    _ fbb: inout FlatBufferBuilder,
    idx: Int32 = 0,
    typeOffset type: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    weightsVectorOffset weights: Offset = Offset(),
    weightsShapeVectorOffset weightsShape: Offset = Offset(),
    biasVectorOffset bias: Offset = Offset(),
    biasShapeVectorOffset biasShape: Offset = Offset(),
    probability: Float32 = 0.0,
    startDim: Int32 = 0,
    endDim: Int32 = 0,
    outSizeVectorOffset outSize: Offset = Offset(),
    eps: Float32 = 0.0,
    momentum: Float32 = 0.0,
    numBatchesTracked: Int32 = 0,
    runningMeanVectorOffset runningMean: Offset = Offset(),
    runningMeanShapeVectorOffset runningMeanShape: Offset = Offset(),
    runningVarVectorOffset runningVar: Offset = Offset(),
    runningVarShapeVectorOffset runningVarShape: Offset = Offset(),
    kernelSizeVectorOffset kernelSize: Offset = Offset(),
    dilationVectorOffset dilation: Offset = Offset(),
    groups: Int32 = 0,
    inChannels: Int32 = 0,
    outChannels: Int32 = 0,
    padModeOffset padMode: Offset = Offset(),
    paddingVectorOffset padding: Offset = Offset(),
    paddingStringOffset paddingString: Offset = Offset(),
    strideVectorOffset stride: Offset = Offset(),
    dataLayoutOffset dataLayout: Offset = Offset(),
    ceilMode: Bool = false,
    upscaleFactor: Int32 = 0
  ) -> Offset {
    let __start = Layer.startLayer(&fbb)
    Layer.add(idx: idx, &fbb)
    Layer.add(type: type, &fbb)
    Layer.add(name: name, &fbb)
    Layer.addVectorOf(weights: weights, &fbb)
    Layer.addVectorOf(weightsShape: weightsShape, &fbb)
    Layer.addVectorOf(bias: bias, &fbb)
    Layer.addVectorOf(biasShape: biasShape, &fbb)
    Layer.add(probability: probability, &fbb)
    Layer.add(startDim: startDim, &fbb)
    Layer.add(endDim: endDim, &fbb)
    Layer.addVectorOf(outSize: outSize, &fbb)
    Layer.add(eps: eps, &fbb)
    Layer.add(momentum: momentum, &fbb)
    Layer.add(numBatchesTracked: numBatchesTracked, &fbb)
    Layer.addVectorOf(runningMean: runningMean, &fbb)
    Layer.addVectorOf(runningMeanShape: runningMeanShape, &fbb)
    Layer.addVectorOf(runningVar: runningVar, &fbb)
    Layer.addVectorOf(runningVarShape: runningVarShape, &fbb)
    Layer.addVectorOf(kernelSize: kernelSize, &fbb)
    Layer.addVectorOf(dilation: dilation, &fbb)
    Layer.add(groups: groups, &fbb)
    Layer.add(inChannels: inChannels, &fbb)
    Layer.add(outChannels: outChannels, &fbb)
    Layer.add(padMode: padMode, &fbb)
    Layer.addVectorOf(padding: padding, &fbb)
    Layer.add(paddingString: paddingString, &fbb)
    Layer.addVectorOf(stride: stride, &fbb)
    Layer.add(dataLayout: dataLayout, &fbb)
    Layer.add(ceilMode: ceilMode, &fbb)
    Layer.add(upscaleFactor: upscaleFactor, &fbb)
    return Layer.endLayer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.idx.p, fieldName: "idx", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.weights.p, fieldName: "weights", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.weightsShape.p, fieldName: "weightsShape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.bias.p, fieldName: "bias", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.biasShape.p, fieldName: "biasShape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.probability.p, fieldName: "probability", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.startDim.p, fieldName: "startDim", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.endDim.p, fieldName: "endDim", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.outSize.p, fieldName: "outSize", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.eps.p, fieldName: "eps", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.momentum.p, fieldName: "momentum", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.numBatchesTracked.p, fieldName: "numBatchesTracked", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.runningMean.p, fieldName: "runningMean", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.runningMeanShape.p, fieldName: "runningMeanShape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.runningVar.p, fieldName: "runningVar", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.runningVarShape.p, fieldName: "runningVarShape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.kernelSize.p, fieldName: "kernelSize", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.dilation.p, fieldName: "dilation", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.groups.p, fieldName: "groups", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.inChannels.p, fieldName: "inChannels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.outChannels.p, fieldName: "outChannels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.padMode.p, fieldName: "padMode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.padding.p, fieldName: "padding", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.paddingString.p, fieldName: "paddingString", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stride.p, fieldName: "stride", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.dataLayout.p, fieldName: "dataLayout", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ceilMode.p, fieldName: "ceilMode", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.upscaleFactor.p, fieldName: "upscaleFactor", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct Layers: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_8() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsLayers(bb: ByteBuffer) -> Layers { return Layers(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case layers = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var hasLayers: Bool { let o = _accessor.offset(VTOFFSET.layers.v); return o == 0 ? false : true }
  public var layersCount: Int32 { let o = _accessor.offset(VTOFFSET.layers.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func layers(at index: Int32) -> Layer? { let o = _accessor.offset(VTOFFSET.layers.v); return o == 0 ? nil : Layer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startLayers(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func addVectorOf(layers: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: layers, at: VTOFFSET.layers.p) }
  public static func endLayers(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLayers(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    layersVectorOffset layers: Offset = Offset()
  ) -> Offset {
    let __start = Layers.startLayers(&fbb)
    Layers.add(name: name, &fbb)
    Layers.addVectorOf(layers: layers, &fbb)
    return Layers.endLayers(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.layers.p, fieldName: "layers", required: false, type: ForwardOffset<Vector<ForwardOffset<Layer>, Layer>>.self)
    _v.finish()
  }
}

